// generated by go-extpoints -- DO NOT EDIT
package extpoints

import (
	"reflect"
	"sync"
)

func typeName(obj interface{}) string {
	return reflect.TypeOf(obj).Elem().Name()
}

var extensions = struct {
	sync.Mutex
	m map[string]*extensionPoint
}{
	m: make(map[string]*extensionPoint),
}

type extensionPoint struct {
	sync.Mutex
	iface      interface{}
	ifaceName  string
	extensions map[string]interface{}
}

func newExtensionPoint(i interface{}) *extensionPoint {
	ep := &extensionPoint{
		iface:      i,
		ifaceName:  typeName(i),
		extensions: make(map[string]interface{}),
	}
	extensions.Lock()
	defer extensions.Unlock()
	extensions.m[ep.ifaceName] = ep
	return ep
}

func (ep *extensionPoint) lookup(name string) (ext interface{}, ok bool) {
	ep.Lock()
	defer ep.Unlock()
	ext, ok = ep.extensions[name]
	return
}

func (ep *extensionPoint) all() map[string]interface{} {
	ep.Lock()
	defer ep.Unlock()
	registered := make(map[string]interface{})
	for k, v := range ep.extensions {
		registered[k] = v
	}
	return registered
}

func (ep *extensionPoint) register(extension interface{}) bool {
	return ep.registerNamed(extension, typeName(extension))
}

func (ep *extensionPoint) registerNamed(extension interface{}, name string) bool {
	ep.Lock()
	defer ep.Unlock()
	_, exists := ep.extensions[name]
	if exists {
		return !exists
	}
	ep.extensions[name] = extension
	return true
}

func implements(extension interface{}) []string {
	var ifaces []string
	for name, ep := range extensions.m {
		if reflect.TypeOf(extension).Implements(reflect.TypeOf(ep.iface).Elem()) {
			ifaces = append(ifaces, name)
		}
	}
	return ifaces
}

func RegisterNamed(extension interface{}, name string) []string {
	extensions.Lock()
	defer extensions.Unlock()
	var ifaces []string
	for _, iface := range implements(extension) {
		if ok := extensions.m[iface].registerNamed(extension, name); ok {
			ifaces = append(ifaces, iface)
		}
	}
	return ifaces
}

func Register(extension interface{}) []string {
	extensions.Lock()
	defer extensions.Unlock()
	var ifaces []string
	for _, iface := range implements(extension) {
		if ok := extensions.m[iface].register(extension); ok {
			ifaces = append(ifaces, iface)
		}
	}
	return ifaces
}

// LifecycleContributor

var LifecycleContributors = &lifecyclecontributors{
	newExtensionPoint(new(LifecycleContributor)),
}

type lifecyclecontributors struct {
	*extensionPoint
}

func (ep *lifecyclecontributors) Register(extension LifecycleContributor) bool {
	return ep.register(extension)
}

func (ep *lifecyclecontributors) RegisterNamed(extension LifecycleContributor, name string) bool {
	return ep.registerNamed(extension, name)
}

func (ep *lifecyclecontributors) Lookup(name string) (LifecycleContributor, bool) {
	ext, ok := ep.lookup(name)
	return ext.(LifecycleContributor), ok
}

func (ep *lifecyclecontributors) All() map[string]LifecycleContributor {
	all := make(map[string]LifecycleContributor)
	for k, v := range ep.all() {
		all[k] = v.(LifecycleContributor)
	}
	return all
}

// CommandProvider

var CommandProviders = &commandproviders{
	newExtensionPoint(new(CommandProvider)),
}

type commandproviders struct {
	*extensionPoint
}

func (ep *commandproviders) Register(extension CommandProvider) bool {
	return ep.register(extension)
}

func (ep *commandproviders) RegisterNamed(extension CommandProvider, name string) bool {
	return ep.registerNamed(extension, name)
}

func (ep *commandproviders) Lookup(name string) (CommandProvider, bool) {
	ext, ok := ep.lookup(name)
	return ext.(CommandProvider), ok
}

func (ep *commandproviders) All() map[string]CommandProvider {
	all := make(map[string]CommandProvider)
	for k, v := range ep.all() {
		all[k] = v.(CommandProvider)
	}
	return all
}
